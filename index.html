import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Power, Activity, Zap, MousePointer2 } from 'lucide-react';

const CRTApp = () => {
  // --- STATE MANAGEMENT ---
  const [isOn, setIsOn] = useState(false);
  
  // Physics Parameters
  const [anodeVoltage, setAnodeVoltage] = useState(2000); // Accelerating voltage (V)
  const [wehneltVoltage, setWehneltVoltage] = useState(0); // Control grid (negative V)
  const [intensity, setIntensity] = useState(80);         // Heater Intensity (Standard höher für bessere Sichtbarkeit)
  
  const [plateYVoltage, setPlateYVoltage] = useState(0);  // Vertical deflection (DC)
  const [plateXVoltage, setPlateXVoltage] = useState(0);  // Horizontal deflection (DC)
  const [frequency, setFrequency] = useState(1);          // For AC mode
  const [timeBase, setTimeBase] = useState(false);        // Auto-sweep X axis
  const [signalType, setSignalType] = useState('dc');     // 'dc', 'ac' (sine)
  const [beamShape, setBeamShape] = useState('point');    // 'point', 'circle', 'star', 'heart', 'sbs'

  // Simulation State
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const electronsRef = useRef([]); // Store particles
  const traceRef = useRef([]);     // Store screen hits
  const timeRef = useRef(0);

  // Constants
  const TUBE_HEIGHT = 200;
  const START_X = 50;
  const SCREEN_X = 750;

  // Component Positions
  const CATHODE_X = 80;
  const WEHNELT_X = 80; 
  const ANODE_X = 180;
  const PLATES_Y_X = 300;
  const PLATES_X_X = 450; 

  // --- HELPER: SHAPE SIGNAL GENERATOR ---
  // Returns normalized {y, z} "Voltages" needed to draw the shape.
  // Range approx -1.0 to 1.0
  const getShapeSignal = (shape) => {
    let y = 0, z = 0;
    
    // We pick a random 't' to draw a random point on the shape's outline each frame.
    // With enough points, it looks solid.

    switch (shape) {
      case 'circle': {
        const t = Math.random() * Math.PI * 2;
        y = Math.sin(t);
        z = Math.cos(t);
        break;
      }
      case 'star': {
        // Parametric Star Logic
        // Pick a random edge (0-4)
        const edge = Math.floor(Math.random() * 5); 
        const rOuter = 1.0;
        const rInner = 0.4;
        
        // Pick a random spot along the spike
        const segment = Math.random(); // 0 to 1 along the spike
        
        // Angles for tip and valley
        const angleTip = (edge * 2 * Math.PI) / 5 - (Math.PI / 2); // Shift to point up
        const angleValleyRight = angleTip + (Math.PI / 5);
        const angleValleyLeft = angleTip - (Math.PI / 5);

        // Decide if we are on left or right slope of the spike
        const isRightSlope = Math.random() > 0.5;

        // Start point (Tip)
        const tipY = Math.sin(angleTip) * rOuter;
        const tipZ = Math.cos(angleTip) * rOuter;

        // End point (Valley)
        const valleyAngle = isRightSlope ? angleValleyRight : angleValleyLeft;
        const valleyY = Math.sin(valleyAngle) * rInner;
        const valleyZ = Math.cos(valleyAngle) * rInner;

        // Interpolate
        y = tipY + (valleyY - tipY) * segment;
        z = tipZ + (valleyZ - tipZ) * segment;
        break;
      }
      case 'heart': {
         // Normalized Heart
         const t = Math.random() * Math.PI * 2;
         z = (16 * Math.pow(Math.sin(t), 3)) / 16;
         y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;
         break;
      }
      case 'sbs': {
        // IMPROVED SBS LOGIC
        // We select which letter to draw based on probability regions
        const selector = Math.random();
        // 0.0 - 0.33: Left S
        // 0.33 - 0.66: B
        // 0.66 - 1.0: Right S

        const scale = 0.8;
        const sWidth = 0.5;
        const bWidth = 0.5;

        if (selector < 0.33 || selector > 0.66) {
            // DRAW 'S'
            // Center depends on left or right
            const centerX = selector < 0.33 ? -0.8 : 0.8;
            
            // S Curve function: use cosine to get the wiggle
            // t goes from -1 (bottom) to 1 (top)
            const t = (Math.random() * 2) - 1; 
            
            y = -t * scale; // Invert y so top is up
            // Z follows a cosine wave to make the S shape
            // cos(PI/2) is 0. cos(-PI/2) is 0.
            // We want ends to curve.
            // Let's use: sin(t * PI) roughly gives a C.
            // We want S: z = sin(t * PI * a) ?
            // Let's try z = 0.5 * sin(t * PI * 1.2 + offset)
            z = centerX + (0.3 * Math.sin(t * Math.PI * 1.3 + Math.PI/4));
            
            // Add top/bottom caps for serif look? (Optional, skipping for cleaner lines)
        } else {
            // DRAW 'B'
            // B is vertical line + two bumps
            const part = Math.random();
            const centerX = 0.0; // Middle

            if (part < 0.3) {
                // Vertical Line on the left side of B
                z = centerX - (bWidth * 0.3);
                y = (Math.random() * 2 - 1) * scale;
            } else {
                // The Bumps (Top or Bottom)
                const isTop = Math.random() > 0.5;
                // Semicircle logic
                // Angle -PI/2 to PI/2
                const angle = (Math.random() * Math.PI) - (Math.PI / 2);
                
                const r = scale * 0.5;
                const yOffset = isTop ? -scale/2 : scale/2;
                
                z = (centerX - (bWidth * 0.3)) + (Math.cos(angle) * bWidth * 0.8);
                y = yOffset + (Math.sin(angle) * r);
            }
        }
        break;
      }
      case 'point':
      default:
        y = 0; z = 0;
        break;
    }
    return { y, z };
  };

  // --- PHYSICS ENGINE ---
  const updatePhysics = () => {
    if (!isOn) {
      electronsRef.current = [];
      return;
    }

    // 1. Control Calculations
    const cutoff = 50; 
    const wehneltTransmission = Math.max(0, 1 - (Math.abs(wehneltVoltage) / cutoff));
    
    // INCREASED SPAWN RATE for solid lines
    // Previous factor was /10. Now we multiply to get high density.
    // If intensity is 100%, we want lots of points.
    let spawnRate = (intensity * 0.8) * wehneltTransmission;
    
    // Safety clamp to prevent browser crash if intensity goes crazy
    if (spawnRate > 200) spawnRate = 200;

    // Wehnelt Focus Jitter
    const initialJitter = 0.2 + (wehneltTransmission * 1.5);

    // 2. AC/DC Logic
    let currentPlateY = plateYVoltage;
    let currentPlateX = plateXVoltage;
    let isBlanking = false;
    let effectiveShape = beamShape;

    timeRef.current += 0.05 * frequency;

    if (signalType === 'ac') {
      effectiveShape = 'point'; 
      currentPlateY = Math.sin(timeRef.current) * 80;
    }

    if (timeBase) {
      const period = 200 / frequency;
      const rawPhase = (timeRef.current * 10 % period) / period; 
      if (rawPhase > 0.95) isBlanking = true;
      currentPlateX = (rawPhase * 200) - 100;
    }

    // 3. Spawn Electrons
    if (!isBlanking) {
      const count = Math.floor(spawnRate) + (Math.random() < (spawnRate % 1) ? 1 : 0);
      
      for (let i = 0; i < count; i++) {
        const shapeSignal = getShapeSignal(effectiveShape);
        const SHAPE_VOLTAGE_MAGNITUDE = 120; 

        electronsRef.current.push({
          x: CATHODE_X,
          y: TUBE_HEIGHT / 2 + (Math.random()-0.5) * initialJitter, 
          z: (Math.random()-0.5) * initialJitter, 
          
          shapeSignalY: shapeSignal.y * SHAPE_VOLTAGE_MAGNITUDE,
          shapeSignalZ: shapeSignal.z * SHAPE_VOLTAGE_MAGNITUDE,

          vx: Math.sqrt(anodeVoltage) * 0.15, 
          vy: 0, 
          vz: 0,
          life: 0
        });
      }
    }

    // 4. Move Electrons
    electronsRef.current.forEach(e => {
      e.x += e.vx;
      e.y += e.vy;
      e.z += e.vz;
      e.life++;

      // Y-Plates
      if (e.x > PLATES_Y_X && e.x < PLATES_Y_X + 80) {
        const totalYVoltage = currentPlateY + e.shapeSignalY;
        const deflectionForce = totalYVoltage * 0.005; 
        e.vy += deflectionForce / (e.vx * 2); 
      }

      // X-Plates
      if (e.x > PLATES_X_X && e.x < PLATES_X_X + 60) {
        const totalXVoltage = currentPlateX + e.shapeSignalZ;
        const deflectionForce = totalXVoltage * 0.005;
        e.vz += deflectionForce / (e.vx * 2);
      }
    });

    // 5. Screen Collision
    electronsRef.current = electronsRef.current.filter(e => {
      if (e.x >= SCREEN_X) {
        traceRef.current.push({
          y: e.y - TUBE_HEIGHT / 2, 
          x: e.z,                   
          alpha: 1.0,
          shape: effectiveShape
        });
        return false;
      }
      return true;
    });

    // 6. Trace Fading (PHOSPHOR PERSISTENCE)
    // Slower fade for shapes to look solid
    traceRef.current = traceRef.current.filter(t => {
      // If it's a shape, fade slowly (0.015). If it's a point/AC trace, fade normal (0.02)
      // This combined with high spawn rate creates the "line" effect.
      const fadeSpeed = t.shape === 'point' ? 0.02 : 0.015;
      t.alpha -= fadeSpeed; 
      return t.alpha > 0;
    });
  };

  // --- RENDERING ---
  const draw = (ctx) => {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    const tubeY = 50; 

    // TUBE
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(START_X, tubeY + 40);
    ctx.lineTo(START_X, tubeY + 160);
    ctx.lineTo(200, tubeY + 160); 
    ctx.lineTo(SCREEN_X - 50, tubeY + 190);
    ctx.lineTo(SCREEN_X, tubeY + 190);      
    ctx.lineTo(SCREEN_X, tubeY + 10);       
    ctx.lineTo(SCREEN_X - 50, tubeY + 10);  
    ctx.lineTo(200, tubeY + 40);   
    ctx.closePath();
    ctx.stroke();
    ctx.fillStyle = 'rgba(20, 30, 40, 0.4)';
    ctx.fill();

    // COMPONENT: Wehnelt
    ctx.fillStyle = '#666';
    ctx.strokeStyle = '#888';
    ctx.fillRect(WEHNELT_X - 10, tubeY + 75, 30, 50); 
    ctx.strokeRect(WEHNELT_X - 10, tubeY + 75, 30, 50);
    if (isOn) {
       const wAlpha = Math.abs(wehneltVoltage) / 60;
       ctx.fillStyle = `rgba(50, 50, 255, ${wAlpha})`;
       ctx.fillRect(WEHNELT_X - 10, tubeY + 75, 30, 50);
    }
    
    // COMPONENT: Cathode
    ctx.fillStyle = isOn ? `rgba(255, 170, 0, ${intensity/100})` : '#442222';
    if (isOn && wehneltVoltage > -45) { 
        ctx.shadowBlur = intensity / 4;
        ctx.shadowColor = 'orange';
    }
    ctx.fillRect(CATHODE_X, tubeY + 90, 10, 20); 
    ctx.shadowBlur = 0;
    
    // COMPONENT: Anode
    ctx.fillStyle = '#888';
    ctx.fillRect(ANODE_X, tubeY + 80, 40, 40);
    ctx.clearRect(ANODE_X, tubeY + 95, 40, 10); 
    ctx.strokeRect(ANODE_X, tubeY + 80, 40, 40);

    // COMPONENT: Y-Plates
    ctx.fillStyle = '#aaa';
    ctx.fillRect(PLATES_Y_X, tubeY + 60, 80, 5); 
    ctx.fillRect(PLATES_Y_X, tubeY + 135, 80, 5); 
    let currentYVolt = signalType === 'ac' ? Math.sin(timeRef.current) * 100 : plateYVoltage;
    if (currentYVolt !== 0) {
      ctx.fillStyle = currentYVolt > 0 ? 'rgba(255, 100, 100, 0.5)' : 'rgba(100, 100, 255, 0.3)';
      ctx.fillRect(PLATES_Y_X, tubeY + 60, 80, 5);
      ctx.fillStyle = currentYVolt < 0 ? 'rgba(255, 100, 100, 0.5)' : 'rgba(100, 100, 255, 0.3)';
      ctx.fillRect(PLATES_Y_X, tubeY + 135, 80, 5);
    }

    // COMPONENT: X-Plates
    ctx.fillStyle = '#444';
    ctx.fillRect(PLATES_X_X, tubeY + 70, 60, 60); 
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 2;
    ctx.strokeRect(PLATES_X_X, tubeY + 70, 60, 60); 
    
    let currentXVolt = timeBase ? ((timeRef.current * 10 % (200/frequency))/(200/frequency)*200 - 100) : plateXVoltage;
    if (Math.abs(currentXVolt) > 5) {
        ctx.fillStyle = currentXVolt > 0 ? 'rgba(255, 50, 50, 0.2)' : 'rgba(50, 50, 255, 0.2)';
        ctx.fillRect(PLATES_X_X, tubeY + 70, 60, 60);
    }

    // ELECTRONS (Side View)
    if (isOn && wehneltVoltage > -48) {
        ctx.fillStyle = '#00ff00';
        electronsRef.current.forEach(e => {
            const viewY = tubeY + e.y;
            const depth = Math.max(0.2, 1 - Math.abs(e.z)/50);
            ctx.globalAlpha = depth;
            ctx.beginPath();
            ctx.arc(e.x, viewY, 2, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;
    }

    // SCREEN VIEW
    const screenCenterX = 900;
    const screenCenterY = 150;
    const radius = 100;

    // Bezel
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(screenCenterX, screenCenterY, radius + 15, 0, Math.PI * 2);
    ctx.fill();
    // Phosphor
    ctx.fillStyle = '#002200';
    ctx.beginPath();
    ctx.arc(screenCenterX, screenCenterY, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Graticule (Grid)
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i = -radius; i < radius; i+=20) {
      ctx.moveTo(screenCenterX + i, screenCenterY - radius);
      ctx.lineTo(screenCenterX + i, screenCenterY + radius);
      ctx.moveTo(screenCenterX - radius, screenCenterY + i);
      ctx.lineTo(screenCenterX + radius, screenCenterY + i);
    }
    ctx.stroke();

    // Trace
    // Improved glow effect
    ctx.shadowBlur = 4;
    ctx.shadowColor = '#00ff00';
    traceRef.current.forEach(point => {
      ctx.fillStyle = `rgba(100, 255, 100, ${point.alpha})`;
      ctx.beginPath();
      ctx.arc(screenCenterX + point.x, screenCenterY + point.y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;

    // Labels
    ctx.fillStyle = 'white';
    ctx.font = '14px sans-serif';
    ctx.fillText("Seitenansicht", START_X, 30);
    ctx.fillText("Bildschirm", screenCenterX - 40, 30);
  };

  const loop = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    updatePhysics();
    draw(ctx);
    animationRef.current = requestAnimationFrame(loop);
  }, [isOn, anodeVoltage, wehneltVoltage, intensity, plateYVoltage, plateXVoltage, frequency, timeBase, signalType, beamShape]);

  useEffect(() => {
    animationRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(animationRef.current);
  }, [loop]);


  // --- RESET ---
  const reset = () => {
    setPlateYVoltage(0);
    setPlateXVoltage(0);
    setAnodeVoltage(2000);
    setWehneltVoltage(0);
    setIntensity(80);
    setSignalType('dc');
    setTimeBase(false);
    setBeamShape('point');
  };

  return (
    <div className="flex flex-col min-h-screen bg-slate-900 text-slate-100 font-sans p-4">
      {/* HEADER */}
      <header className="flex flex-wrap justify-between items-center mb-6 pb-4 border-b border-slate-700">
        <div>
          <h1 className="text-2xl font-bold text-green-400 flex items-center gap-2">
            <Activity className="w-6 h-6" />
            Braunsche Röhre Simulator
          </h1>
          <p className="text-slate-400 text-sm">Hochschule/Schulphysik-Modus</p>
        </div>
        <button 
          onClick={() => setIsOn(!isOn)}
          className={`px-6 py-2 rounded-full font-bold transition-all flex items-center gap-2 mt-2 sm:mt-0 ${isOn ? 'bg-green-500 hover:bg-green-400 text-slate-900 shadow-[0_0_15px_rgba(34,197,94,0.6)]' : 'bg-slate-700 hover:bg-slate-600 text-slate-300'}`}
        >
          <Power className="w-4 h-4" />
          {isOn ? "AN" : "AUS"}
        </button>
      </header>

      {/* MAIN CONTENT GRID */}
      <div className="flex flex-col lg:flex-row gap-6">
        
        {/* CANVAS */}
        <div className="flex-grow bg-slate-800 rounded-xl overflow-hidden shadow-xl border border-slate-700 relative min-h-[350px]">
          <canvas 
            ref={canvasRef} 
            width={1100} 
            height={350}
            className="w-full h-full object-contain bg-slate-950"
          />
        </div>

        {/* CONTROLS */}
        <div className="w-full lg:w-96 flex flex-col gap-4">
          
          {/* 1. Beam Gen */}
          <div className="bg-slate-800 p-4 rounded-xl border border-slate-700">
            <h3 className="text-sm font-semibold text-green-400 mb-3 flex items-center gap-2">
              <Zap className="w-4 h-4" /> Elektronenkanone
            </h3>
            
            {/* Anode */}
            <div className="mb-4">
              <div className="flex justify-between text-xs mb-1">
                <span>Anodenspannung ($U_A$)</span>
                <span className="text-green-300">{anodeVoltage} V</span>
              </div>
              <input 
                type="range" min="300" max="4000" step="100"
                value={anodeVoltage}
                onChange={(e) => setAnodeVoltage(Number(e.target.value))}
                className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-green-500"
              />
               <p className="text-[10px] text-slate-500 mt-1">Niedrige Spannung = Größeres Symbol</p>
            </div>

            {/* Wehnelt */}
            <div className="mb-4">
              <div className="flex justify-between text-xs mb-1">
                <span>Wehnelt-Zylinder</span>
                <span className={`font-mono ${wehneltVoltage < -40 ? 'text-red-400' : 'text-blue-300'}`}>{wehneltVoltage} V</span>
              </div>
              <input 
                type="range" min="-60" max="0" step="1"
                value={wehneltVoltage}
                onChange={(e) => setWehneltVoltage(Number(e.target.value))}
                className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500 dir-rtl"
              />
              <p className="text-[10px] text-slate-500 mt-1">Negativ = Feinerer Strahl / Abschaltung</p>
            </div>

            {/* Heater */}
            <div>
              <div className="flex justify-between text-xs mb-1">
                <span>Glühdraht Intensität</span>
                <span className="text-orange-300">{intensity}%</span>
              </div>
              <input 
                type="range" min="0" max="100"
                value={intensity}
                onChange={(e) => setIntensity(Number(e.target.value))}
                className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-orange-500"
              />
            </div>
          </div>

           {/* 2. Shape Selector */}
           <div className="bg-slate-800 p-4 rounded-xl border border-slate-700">
            <h3 className="text-sm font-semibold text-purple-400 mb-3 flex items-center gap-2">
              Form-Maske (Nur DC Modus)
            </h3>
            <div className="grid grid-cols-5 gap-2">
              {[
                {id: 'point', label: '•'},
                {id: 'circle', label: '◯'},
                {id: 'star', label: '★'},
                {id: 'heart', label: '♥'},
                {id: 'sbs', label: 'SBS'}
              ].map(s => (
                <button
                  key={s.id}
                  onClick={() => setBeamShape(s.id)}
                  disabled={signalType === 'ac'}
                  className={`py-2 rounded font-bold text-xs transition-colors 
                    ${beamShape === s.id ? 'bg-purple-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}
                    ${signalType === 'ac' ? 'opacity-30 cursor-not-allowed' : ''}
                  `}
                >
                  {s.label}
                </button>
              ))}
            </div>
          </div>

          {/* 3. Deflection */}
          <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 flex-grow">
            <div className="flex justify-between items-start mb-3">
              <h3 className="text-sm font-semibold text-blue-400 flex items-center gap-2">
                <MousePointer2 className="w-4 h-4" /> Ablenkung
              </h3>
              <button onClick={reset} className="text-xs text-slate-400 hover:text-white underline">Reset</button>
            </div>

            {/* Mode Switch */}
            <div className="flex bg-slate-900 rounded-lg p-1 mb-4">
              <button onClick={() => { setSignalType('dc'); setTimeBase(false); }}
                className={`flex-1 py-1 text-xs rounded ${signalType === 'dc' && !timeBase ? 'bg-blue-600 text-white' : 'text-slate-400'}`}>
                DC (Manuell)
              </button>
              <button onClick={() => { setSignalType('ac'); setTimeBase(true); }}
                className={`flex-1 py-1 text-xs rounded ${signalType === 'ac' ? 'bg-blue-600 text-white' : 'text-slate-400'}`}>
                AC (Oszi)
              </button>
            </div>

            {signalType === 'dc' && !timeBase ? (
              <div className="space-y-4">
                {/* Y Control */}
                <div>
                   <div className="flex justify-between text-xs mb-1 text-slate-400">
                      <span>Y-Ablenkung</span><span>{plateYVoltage}V</span>
                   </div>
                   <input 
                      type="range" min="-100" max="100"
                      value={plateYVoltage}
                      onChange={(e) => setPlateYVoltage(Number(e.target.value))}
                      className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                    />
                </div>
                {/* X Control */}
                <div>
                   <div className="flex justify-between text-xs mb-1 text-slate-400">
                      <span>X-Ablenkung</span><span>{plateXVoltage}V</span>
                   </div>
                   <input 
                      type="range" min="-100" max="100"
                      value={plateXVoltage}
                      onChange={(e) => setPlateXVoltage(Number(e.target.value))}
                      className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                    />
                </div>
              </div>
            ) : (
              <div>
                <div className="flex justify-between text-xs mb-1">
                  <span>Frequenz (Oszilloskop)</span>
                  <span className="text-blue-300">{frequency.toFixed(1)} Hz</span>
                </div>
                <input 
                  type="range" min="0.1" max="5.0" step="0.1"
                  value={frequency}
                  onChange={(e) => setFrequency(Number(e.target.value))}
                  className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-purple-500"
                />
                <p className="text-[10px] text-slate-500 mt-2">Im AC Modus wird der Strahl automatisch fokussiert.</p>
              </div>
            )}
          </div>

        </div>
      </div>
    </div>
  );
};

export default CRTApp;
